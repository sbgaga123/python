1 函数对象（第一类对象）
    函数可以被当成数据来传递
        def func():
            pass

        可以被引用
        可以当做参数传递给另外一个函数
        可以作为函数的返回值
        可以当做容器类型的元素
        def func1():
            print('func1')


        def func2():
            print('func2')



        dic={
            'func1':func1,
            'func2':func2,
        }

        dic['func1']()

2 函数的嵌套
    函数的嵌套调用：在调用函数的过程中又调用了其他的函数
    函数的嵌套定义：在定义函数时，又使用def关键字定义了其他函数
        def f1():
            def f2():
                def f3():
                    print(x)





3 名称空间与作用域
    1 内置名称空间
    2 全局名称空间
    3 局部名称空间
    1和2属于全局范围，全局作用域：全局有效，在任何位置都能被访问到，除非被删除，否则存活到文件执行结束
    3属于局部范围，局部作用域：局部有效，只能在函数内部被访问到，在函数执行结束后，就释放了





4 闭包
    1. 定义在函数内部的函数
    2. 该内部函数包含对外部作用域而不是对全局作用域的引用

    def f1():
        x=1
        def f2():
            print(x)

        return f2
    f=f1()
    x=100000
    f()


5 装饰器
    为什么要有装饰器：
        开放封闭原则，对扩展是开放的，对修改是封闭

    什么是装饰器：
        装饰器本身-》可以是任意可调用对象
        被装饰的对象-》也是任意可调用对象

    装饰器要遵循的原则：
        1. 不修改被装饰器对象的源代码
        2. 不修改被装饰对象的调用方式

    @deco  #func=deco(func)
    def func():
        pass

    @deco1
    @deco2
    def func():
        pass



    @deco1(x) #@res  #func=res(func)
    def func():
        pass



6 迭代器
    迭代：重复上一次过程，每一迭代都基于上一次执行地结果而继续进行
    可迭代对象？
        obj.__iter__

    迭代器对象：
        obj.__iter__
        obj.__next__

    为何要有迭代器：
        提供一种不依赖于索引的迭代方式


    for i in obj: #obj.__iter__()
        pass


    迭代器的优缺点：
        优点：
            1.提供一种不依赖于索引的迭代方式
            2. 节省内存

        缺点：
            1.无法获取长度
            2.一次性



7 生成器
    函数体内含有yield关键字，那该函数的执行结果是生成器对象
    生成器对象本质就是迭代器，所以yield的功能是
        1. 把函数的执行结果做成迭代器
        2. 可以返回多次值，而return只能返回一次值
        3. 可以挂起函数的执行



9 内置函数




